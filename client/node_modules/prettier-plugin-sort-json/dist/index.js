"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.options = exports.parsers = void 0;
const parser_babel_1 = require("prettier/parser-babel");
/**
 * Lexical sort function for strings, meant to be used as the sort
 * function for `Array.prototype.sort`.
 *
 * @param a - First element to compare.
 * @param b - Second element to compare.
 * @returns A number indicating which element should come first.
 */
function lexicalSort(a, b) {
    return a > b ? 1 : -1;
}
const integerPrefixRegex = /^(\d+)/u;
/**
 * Numeric sort function for strings, meant to be used as the sort
 * function for `Array.prototype.sort`.
 *
 * The number prefixing each string (if any) is sorted numerically.
 * Otherwise the string is sorted Lexically.
 *
 * @param a - First element to compare.
 * @param b - Second element to compare.
 * @returns A number indicating which element should come first.
 */
function numericSort(a, b) {
    const aPrefixResult = a.match(integerPrefixRegex);
    const bPrefixResult = b.match(integerPrefixRegex);
    if (aPrefixResult !== null && bPrefixResult !== null) {
        // Guaranteed to be non-null because we checked for `null`, and because there is a capture
        // group in the regex
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        const rawAPrefix = aPrefixResult[1];
        const rawBPrefix = bPrefixResult[1];
        /* eslint-enable @typescript-eslint/no-non-null-assertion */
        const aPrefix = parseInt(rawAPrefix, 10);
        const bPrefix = parseInt(rawBPrefix, 10);
        const difference = aPrefix - bPrefix;
        if (difference !== 0) {
            return difference;
        }
    }
    return String(a) > String(b) ? 1 : -1;
}
/**
 * Reverse a sort function. This is meant to wrap functions meant to be
 * used as the sort function for `Array.prototype.sort`.
 *
 * @param sortFunction - The sort function to reverse.
 * @returns A reversed sort function.
 */
function reverseSort(sortFunction) {
    return (a, b) => {
        return -1 * sortFunction(a, b);
    };
}
/**
 * Make a sort function case-insensitive.. This is meant to wrap
 * functions meant to be used as the sort function for
 * `Array.prototype.sort`.
 *
 * @param sortFunction - The sort function to make case-insensitive.
 * @returns A case-insensitive sort function.
 */
function caseInsensitiveSort(sortFunction) {
    return (a, b) => {
        return sortFunction(a.toLowerCase(), b.toLowerCase());
    };
}
/**
 * Sorting algorithms for categories in a custom sort order definition.
 */
var CategorySort;
(function (CategorySort) {
    CategorySort["CaseInsensitiveLexical"] = "caseInsensitiveLexical";
    CategorySort["CaseInsensitiveNumeric"] = "caseInsensitiveNumeric";
    CategorySort["CaseInsensitiveReverseLexical"] = "caseInsensitiveReverseLexical";
    CategorySort["CaseInsensitiveReverseNumeric"] = "caseInsensitiveReverseNumeric";
    CategorySort["Lexical"] = "lexical";
    CategorySort["Numeric"] = "numeric";
    CategorySort["ReverseLexical"] = "reverseLexical";
    CategorySort["ReverseNumeric"] = "reverseNumeric";
})(CategorySort || (CategorySort = {}));
/**
 * A mapping of category sort algorithms to sort functions.
 */
const categorySortFunctions = {
    [CategorySort.CaseInsensitiveLexical]: caseInsensitiveSort(lexicalSort),
    [CategorySort.CaseInsensitiveNumeric]: caseInsensitiveSort(numericSort),
    [CategorySort.CaseInsensitiveReverseLexical]: caseInsensitiveSort(reverseSort(lexicalSort)),
    [CategorySort.CaseInsensitiveReverseNumeric]: caseInsensitiveSort(reverseSort(numericSort)),
    [CategorySort.Lexical]: lexicalSort,
    [CategorySort.Numeric]: numericSort,
    [CategorySort.ReverseLexical]: reverseSort(lexicalSort),
    [CategorySort.ReverseNumeric]: reverseSort(numericSort),
};
/**
 * A list of all allowed category sort values.
 */
const allowedCategorySortValues = [null, ...Object.keys(categorySortFunctions)];
/**
 * Sort properties of JavaScript objects within an AST.
 *
 * @param ast - The AST to sort.
 * @param recursive - Whether to sort the object recursively or not.
 * @param sortCompareFunction - A custom sort function.
 * @returns The sorted object.
 */
function sortAst(ast, recursive, sortCompareFunction) {
    if (ast.type === 'ArrayExpression' && recursive) {
        ast.elements = ast.elements.map((element) => {
            if (element === null || element.type === 'NullLiteral') {
                return element;
            }
            // SpreadElement is not possible in a JSON file
            return sortAst(element, recursive, sortCompareFunction);
        });
    }
    else if (ast.type === 'ObjectExpression') {
        ast.properties = ast.properties.sort((propertyA, propertyB) => {
            return sortCompareFunction(propertyA.key.value, propertyB.key.value);
        });
        if (recursive) {
            ast.properties = ast.properties.map((property) => {
                if (['ObjectExpression', 'ArrayExpression'].includes(property.value.type)) {
                    property.value = sortAst(property.value, recursive, sortCompareFunction);
                }
                return property;
            });
        }
    }
    return ast;
}
exports.parsers = {
    json: Object.assign(Object.assign({}, parser_babel_1.parsers.json), { parse(text, _parsers, options) {
            const ast = parser_babel_1.parsers.json.parse(text, _parsers, options);
            const { jsonRecursiveSort, jsonSortOrder } = options;
            // Only objects are intended to be sorted by this plugin
            // Arrays are considered only in recursive mode, so that we
            // can get to nested objected.
            if (!(ast.type === 'ObjectExpression' ||
                (ast.type === 'ArrayExpression' && jsonRecursiveSort))) {
                return ast;
            }
            let sortCompareFunction = lexicalSort;
            if (jsonSortOrder) {
                let parsedCustomSort;
                try {
                    parsedCustomSort = JSON.parse(jsonSortOrder);
                }
                catch (error) {
                    // @ts-expect-error Error cause property not yet supported by '@types/node' (see https://github.com/DefinitelyTyped/DefinitelyTyped/pull/61827)
                    throw new Error(`Failed to parse sort order option as JSON`, {
                        cause: error,
                    });
                }
                if (Array.isArray(parsedCustomSort) ||
                    typeof parsedCustomSort !== 'object') {
                    throw new Error(`Invalid custom sort order; must be an object`);
                }
                for (const categorySort of Object.values(parsedCustomSort)) {
                    if (!allowedCategorySortValues.includes(categorySort)) {
                        throw new Error(`Invalid custom sort entry: value must be one of '${String(allowedCategorySortValues)}', got '${String(categorySort)}'`);
                    }
                }
                const customSort = parsedCustomSort;
                const evaluateSortEntry = (value, entry) => {
                    const regexRegex = /^\/(.+)\/([imsu]*)$/u;
                    if (entry.match(regexRegex)) {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const [, regexSpec, flags] = entry.match(regexRegex);
                        // "regexSpec" guaranteed to be defined because of capture group. False positive for unnecessary type assertion.
                        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                        const regex = new RegExp(regexSpec, flags);
                        return value.match(regex);
                    }
                    return value === entry;
                };
                const sortEntries = Object.keys(customSort);
                sortCompareFunction = (a, b) => {
                    const aIndex = sortEntries.findIndex(evaluateSortEntry.bind(null, a));
                    const bIndex = sortEntries.findIndex(evaluateSortEntry.bind(null, b));
                    if (aIndex === -1 && bIndex === -1) {
                        return lexicalSort(a, b);
                    }
                    else if (bIndex === -1) {
                        return -1;
                    }
                    else if (aIndex === -1) {
                        return 1;
                    }
                    else if (aIndex === bIndex) {
                        // Sort entry guaranteed to be non-null because index was found
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const sortEntry = sortEntries[aIndex];
                        // Guaranteed to be defined because `sortEntry` is derived from `Object.keys`
                        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                        const categorySort = customSort[sortEntry];
                        const categorySortFunction = categorySort === null
                            ? lexicalSort
                            : categorySortFunctions[categorySort];
                        return categorySortFunction(a, b);
                    }
                    return aIndex - bIndex;
                };
            }
            return sortAst(ast, jsonRecursiveSort, sortCompareFunction);
        } }),
};
exports.options = {
    jsonRecursiveSort: {
        category: 'json-sort',
        default: false,
        description: 'Sort JSON files recursively, including any nested properties',
        since: '0.0.2',
        type: 'boolean',
    },
    jsonSortOrder: {
        category: 'json-sort',
        description: 'A JSON string specifying a custom sort order',
        since: '0.0.4',
        type: 'string',
    },
};
//# sourceMappingURL=index.js.map