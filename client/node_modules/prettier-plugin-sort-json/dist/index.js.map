{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ArrayExpression,\n  Expression,\n  ObjectExpression,\n  ObjectProperty,\n  NullLiteral,\n  SpreadElement,\n  StringLiteral,\n} from '@babel/types';\nimport { Parser } from 'prettier';\nimport { parsers as babelParsers } from 'prettier/parser-babel';\n\n/**\n * Lexical sort function for strings, meant to be used as the sort\n * function for `Array.prototype.sort`.\n *\n * @param a - First element to compare.\n * @param b - Second element to compare.\n * @returns A number indicating which element should come first.\n */\nfunction lexicalSort(a: string, b: string) {\n  return a > b ? 1 : -1;\n}\n\nconst integerPrefixRegex = /^(\\d+)/u;\n\n/**\n * Numeric sort function for strings, meant to be used as the sort\n * function for `Array.prototype.sort`.\n *\n * The number prefixing each string (if any) is sorted numerically.\n * Otherwise the string is sorted Lexically.\n *\n * @param a - First element to compare.\n * @param b - Second element to compare.\n * @returns A number indicating which element should come first.\n */\nfunction numericSort(a: string, b: string) {\n  const aPrefixResult = a.match(integerPrefixRegex);\n  const bPrefixResult = b.match(integerPrefixRegex);\n  if (aPrefixResult !== null && bPrefixResult !== null) {\n    // Guaranteed to be non-null because we checked for `null`, and because there is a capture\n    // group in the regex\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    const rawAPrefix = aPrefixResult[1]!;\n    const rawBPrefix = bPrefixResult[1]!;\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    const aPrefix = parseInt(rawAPrefix, 10);\n    const bPrefix = parseInt(rawBPrefix, 10);\n    const difference = aPrefix - bPrefix;\n    if (difference !== 0) {\n      return difference;\n    }\n  }\n  return String(a) > String(b) ? 1 : -1;\n}\n\n/**\n * Reverse a sort function. This is meant to wrap functions meant to be\n * used as the sort function for `Array.prototype.sort`.\n *\n * @param sortFunction - The sort function to reverse.\n * @returns A reversed sort function.\n */\nfunction reverseSort(sortFunction: (a: string, b: string) => number) {\n  return (a: string, b: string) => {\n    return -1 * sortFunction(a, b);\n  };\n}\n\n/**\n * Make a sort function case-insensitive.. This is meant to wrap\n * functions meant to be used as the sort function for\n * `Array.prototype.sort`.\n *\n * @param sortFunction - The sort function to make case-insensitive.\n * @returns A case-insensitive sort function.\n */\nfunction caseInsensitiveSort(sortFunction: (a: string, b: string) => number) {\n  return (a: string, b: string) => {\n    return sortFunction(a.toLowerCase(), b.toLowerCase());\n  };\n}\n\n/**\n * Sorting algorithms for categories in a custom sort order definition.\n */\nenum CategorySort {\n  CaseInsensitiveLexical = 'caseInsensitiveLexical',\n  CaseInsensitiveNumeric = 'caseInsensitiveNumeric',\n  CaseInsensitiveReverseLexical = 'caseInsensitiveReverseLexical',\n  CaseInsensitiveReverseNumeric = 'caseInsensitiveReverseNumeric',\n  Lexical = 'lexical',\n  Numeric = 'numeric',\n  ReverseLexical = 'reverseLexical',\n  ReverseNumeric = 'reverseNumeric',\n}\n\n/**\n * A mapping of category sort algorithms to sort functions.\n */\nconst categorySortFunctions = {\n  [CategorySort.CaseInsensitiveLexical]: caseInsensitiveSort(lexicalSort),\n  [CategorySort.CaseInsensitiveNumeric]: caseInsensitiveSort(numericSort),\n  [CategorySort.CaseInsensitiveReverseLexical]: caseInsensitiveSort(\n    reverseSort(lexicalSort),\n  ),\n  [CategorySort.CaseInsensitiveReverseNumeric]: caseInsensitiveSort(\n    reverseSort(numericSort),\n  ),\n  [CategorySort.Lexical]: lexicalSort,\n  [CategorySort.Numeric]: numericSort,\n  [CategorySort.ReverseLexical]: reverseSort(lexicalSort),\n  [CategorySort.ReverseNumeric]: reverseSort(numericSort),\n};\n\n/**\n * A list of all allowed category sort values.\n */\nconst allowedCategorySortValues = [null, ...Object.keys(categorySortFunctions)];\n\n/**\n * Sort properties of JavaScript objects within an AST.\n *\n * @param ast - The AST to sort.\n * @param recursive - Whether to sort the object recursively or not.\n * @param sortCompareFunction - A custom sort function.\n * @returns The sorted object.\n */\nfunction sortAst(\n  ast: Expression,\n  recursive: boolean,\n  sortCompareFunction: (a: string, b: string) => number,\n): Expression {\n  if (ast.type === 'ArrayExpression' && recursive) {\n    ast.elements = ast.elements.map(\n      (element: null | NullLiteral | Expression | SpreadElement) => {\n        if (element === null || element.type === 'NullLiteral') {\n          return element;\n        }\n        // SpreadElement is not possible in a JSON file\n        return sortAst(element as Expression, recursive, sortCompareFunction);\n      },\n    );\n  } else if (ast.type === 'ObjectExpression') {\n    ast.properties = (ast.properties as ObjectProperty[]).sort(\n      (propertyA: ObjectProperty, propertyB: ObjectProperty) => {\n        return sortCompareFunction(\n          (propertyA.key as StringLiteral).value,\n          (propertyB.key as StringLiteral).value,\n        );\n      },\n    );\n\n    if (recursive) {\n      ast.properties = (ast.properties as ObjectProperty[]).map(\n        (property: ObjectProperty) => {\n          if (\n            ['ObjectExpression', 'ArrayExpression'].includes(\n              property.value.type,\n            )\n          ) {\n            property.value = sortAst(\n              property.value as ArrayExpression | ObjectExpression,\n              recursive,\n              sortCompareFunction,\n            );\n          }\n          return property;\n        },\n      );\n    }\n  }\n  return ast;\n}\n\nexport const parsers = {\n  json: {\n    ...babelParsers.json,\n    parse(text, _parsers, options: any) {\n      const ast: Expression = babelParsers.json.parse(text, _parsers, options);\n\n      const { jsonRecursiveSort, jsonSortOrder } = options;\n\n      // Only objects are intended to be sorted by this plugin\n      // Arrays are considered only in recursive mode, so that we\n      // can get to nested objected.\n      if (\n        !(\n          ast.type === 'ObjectExpression' ||\n          (ast.type === 'ArrayExpression' && jsonRecursiveSort)\n        )\n      ) {\n        return ast;\n      }\n\n      let sortCompareFunction: (a: string, b: string) => number = lexicalSort;\n      if (jsonSortOrder) {\n        let parsedCustomSort;\n        try {\n          parsedCustomSort = JSON.parse(jsonSortOrder);\n        } catch (error) {\n          // @ts-expect-error Error cause property not yet supported by '@types/node' (see https://github.com/DefinitelyTyped/DefinitelyTyped/pull/61827)\n          throw new Error(`Failed to parse sort order option as JSON`, {\n            cause: error,\n          });\n        }\n\n        if (\n          Array.isArray(parsedCustomSort) ||\n          typeof parsedCustomSort !== 'object'\n        ) {\n          throw new Error(`Invalid custom sort order; must be an object`);\n        }\n\n        for (const categorySort of Object.values(parsedCustomSort)) {\n          if (!allowedCategorySortValues.includes(categorySort as any)) {\n            throw new Error(\n              `Invalid custom sort entry: value must be one of '${String(\n                allowedCategorySortValues,\n              )}', got '${String(categorySort)}'`,\n            );\n          }\n        }\n        const customSort = parsedCustomSort as Record<\n          string,\n          null | CategorySort\n        >;\n\n        const evaluateSortEntry = (value: string, entry: string) => {\n          const regexRegex = /^\\/(.+)\\/([imsu]*)$/u;\n          if (entry.match(regexRegex)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const [, regexSpec, flags]: string[] = entry.match(regexRegex)!;\n            // \"regexSpec\" guaranteed to be defined because of capture group. False positive for unnecessary type assertion.\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            const regex = new RegExp(regexSpec as string, flags);\n            return value.match(regex);\n          }\n          return value === entry;\n        };\n\n        const sortEntries = Object.keys(customSort);\n\n        sortCompareFunction = (a: string, b: string) => {\n          const aIndex = sortEntries.findIndex(evaluateSortEntry.bind(null, a));\n          const bIndex = sortEntries.findIndex(evaluateSortEntry.bind(null, b));\n\n          if (aIndex === -1 && bIndex === -1) {\n            return lexicalSort(a, b);\n          } else if (bIndex === -1) {\n            return -1;\n          } else if (aIndex === -1) {\n            return 1;\n          } else if (aIndex === bIndex) {\n            // Sort entry guaranteed to be non-null because index was found\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const sortEntry = sortEntries[aIndex]!;\n            // Guaranteed to be defined because `sortEntry` is derived from `Object.keys`\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            const categorySort = customSort[sortEntry] as null | CategorySort;\n            const categorySortFunction =\n              categorySort === null\n                ? lexicalSort\n                : categorySortFunctions[categorySort];\n            return categorySortFunction(a, b);\n          }\n          return aIndex - bIndex;\n        };\n      }\n      return sortAst(ast, jsonRecursiveSort, sortCompareFunction);\n    },\n  },\n} as Record<string, Parser>;\n\nexport const options = {\n  jsonRecursiveSort: {\n    category: 'json-sort',\n    default: false,\n    description: 'Sort JSON files recursively, including any nested properties',\n    since: '0.0.2',\n    type: 'boolean' as const,\n  },\n  jsonSortOrder: {\n    category: 'json-sort',\n    description: 'A JSON string specifying a custom sort order',\n    since: '0.0.4',\n    type: 'string' as const,\n  },\n};\n"]}